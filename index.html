<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Urban Drive — Prototype (fonctionnel)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0f1114;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#fff}
    #ui { position: absolute; left:12px; top:12px; z-index:20; display:flex; flex-direction:column; gap:8px; }
    .panel { background:rgba(0,0,0,0.45); padding:8px 12px; border-radius:8px; }
    .btn { background:#111; color:#fff; border:1px solid rgba(255,255,255,0.06); padding:6px 10px; border-radius:6px; cursor:pointer; }
    #mobileControls { position: absolute; right:12px; bottom:12px; z-index:20; display:none; gap:8px; }
    .mbtn{ width:64px; height:56px; border-radius:10px; background:rgba(255,255,255,0.06); color:#fff; font-weight:700; font-size:20px; border:none; }
    #loading { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:#ddd; background:rgba(0,0,0,0.6); padding:10px 14px; border-radius:8px; display:none; z-index:30; }
    #message { font-size:13px; color:#ccc; margin-top:6px; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div style="font-weight:700">Urban Drive — Prototype</div>
      <div style="margin-top:8px">Speed: <span id="speed">0</span> | Score: <span id="score">0</span></div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button id="startBtn" class="btn">Démarrer</button>
        <button id="resetBtn" class="btn">Reset</button>
      </div>
      <div id="message">Contrôles: W/A/S/D ou flèches — Espace turbo</div>
    </div>
  </div>

  <div id="mobileControls">
    <button id="leftBtn" class="mbtn">◀</button>
    <button id="upBtn" class="mbtn">▲</button>
    <button id="rightBtn" class="mbtn">▶</button>
  </div>

  <div id="loading">Chargement…</div>

  <!-- Three.js CDN (fallback loading handled in script) -->
  <script>
  (function(){
    // If THREE is not loaded, inject script then run main.
    function loadScript(url, cb){
      const s = document.createElement('script');
      s.src = url;
      s.onload = cb;
      s.onerror = function(){ console.error('Impossible de charger', url); cb(new Error('load error')); };
      document.head.appendChild(s);
    }

    function main() {
      // Use THREE here
      if (typeof THREE === 'undefined') {
        console.error('Three.js non disponible');
        return;
      }

      // UI elements
      const startBtn = document.getElementById('startBtn');
      const resetBtn = document.getElementById('resetBtn');
      const loading = document.getElementById('loading');
      const speedEl = document.getElementById('speed');
      const scoreEl = document.getElementById('score');
      const mobileControls = document.getElementById('mobileControls');
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const upBtn = document.getElementById('upBtn');

      // Input state
      const keys = { forward:false, backward:false, left:false, right:false, turbo:false };

      // Scene variables
      let renderer, scene, camera, composer;
      let vehicle, obstacles = [], particles = [];
      let speed = 0, score = 0;
      let running = false;
      let lastTime = performance.now();

      // Simple audio context unlocked on gesture
      let audioCtx = null;
      function ensureAudio(){
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      }

      // Attach keyboard
      window.addEventListener('keydown', (e)=>{
        if (['ArrowUp','KeyW'].includes(e.code)) keys.forward = true;
        if (['ArrowDown','KeyS'].includes(e.code)) keys.backward = true;
        if (['ArrowLeft','KeyA'].includes(e.code)) keys.left = true;
        if (['ArrowRight','KeyD'].includes(e.code)) keys.right = true;
        if (e.code === 'Space') keys.turbo = true;
      });
      window.addEventListener('keyup', (e)=>{
        if (['ArrowUp','KeyW'].includes(e.code)) keys.forward = false;
        if (['ArrowDown','KeyS'].includes(e.code)) keys.backward = false;
        if (['ArrowLeft','KeyA'].includes(e.code)) keys.left = false;
        if (['ArrowRight','KeyD'].includes(e.code)) keys.right = false;
        if (e.code === 'Space') keys.turbo = false;
      });

      // Mobile buttons
      function touchStartHandler(key){ return (e)=>{ e.preventDefault(); keys[key] = true; }; }
      function touchEndHandler(key){ return (e)=>{ e.preventDefault(); keys[key] = false; }; }
      leftBtn.addEventListener('touchstart', touchStartHandler('left')); leftBtn.addEventListener('touchend', touchEndHandler('left'));
      rightBtn.addEventListener('touchstart', touchStartHandler('right')); rightBtn.addEventListener('touchend', touchEndHandler('right'));
      upBtn.addEventListener('touchstart', touchStartHandler('forward')); upBtn.addEventListener('touchend', touchEndHandler('forward'));

      // Start / Reset wiring
      startBtn.addEventListener('click', ()=>{
        ensureAudio();
        startBtn.disabled = true;
        loading.style.display = 'block';
        setTimeout(()=>{ // small yield so UI updates
          if (!renderer) initScene();
          loading.style.display = 'none';
          running = true;
          lastTime = performance.now();
          animate();
        }, 80);
      });

      resetBtn.addEventListener('click', ()=>{
        resetScene();
      });

      // If mobile, show mobile controls
      if (/Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 700) {
        mobileControls.style.display = 'flex';
      }

      // Initialize minimal scene
      function initScene() {
        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Scene and camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f1114);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
        camera.position.set(0,6,-12);

        // Lights
        const hemi = new THREE.HemisphereLight(0xbfeaff, 0x202020, 0.6);
        scene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 1.0);
        dir.position.set(30,80,20);
        dir.castShadow = true;
        dir.shadow.camera.near = 1; dir.shadow.camera.far = 500;
        dir.shadow.camera.left = -200; dir.shadow.camera.right = 200;
        dir.shadow.camera.top = 200; dir.shadow.camera.bottom = -200;
        dir.shadow.mapSize.set(1024,1024);
        scene.add(dir);

        // Ground
        const groundMat = new THREE.MeshStandardMaterial({ color:0x222224, roughness:0.8 });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000,1,1), groundMat);
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;
        scene.add(ground);

        // Create simple city (boxes)
        createCity();

        // Create player vehicle
        createVehicle();

        // initial obstacles
        createObstacles(16);

        window.addEventListener('resize', onWindowResize);
      }

      function createCity() {
        const colors = [0x555788, 0x8ea7ff, 0xd6c4a1, 0x9fd1a0, 0xffd37a];
        for (let i=0;i<45;i++){
          const w = 6 + Math.random()*26;
          const d = 6 + Math.random()*26;
          const h = 6 + Math.random()*80;
          const mat = new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random()*colors.length)], roughness:0.7 });
          const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
          b.position.set((Math.random()-0.5)*800, h/2, (Math.random()-0.5)*1200);
          b.castShadow = true; b.receiveShadow = true;
          scene.add(b);
        }
      }

      function createVehicle() {
        vehicle = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(3.2,1.2,6.0), new THREE.MeshStandardMaterial({ color:0x0ec0ff, metalness:0.2, roughness:0.3 }));
        body.position.y = 0.9;
        body.castShadow = true;
        vehicle.add(body);
        const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.9,3.0), new THREE.MeshStandardMaterial({ color:0x073e52, metalness:0.15, roughness:0.25 }));
        cabin.position.set(0,1.4,-0.4);
        cabin.castShadow = true; vehicle.add(cabin);
        // simple wheels
        const wheelGeo = new THREE.CylinderGeometry(0.6,0.6,0.8,12);
        wheelGeo.rotateZ(Math.PI/2);
        const wheelMat = new THREE.MeshStandardMaterial({ color:0x0b0b0b, metalness:0.8, roughness:0.4 });
        const offsets = [[-1.4,0.4,2.4],[1.4,0.4,2.4],[-1.4,0.4,-2.4],[1.4,0.4,-2.4]];
        for (const off of offsets){
          const w = new THREE.Mesh(wheelGeo, wheelMat);
          w.position.set(off[0], off[1], off[2]);
          w.castShadow = true; vehicle.add(w);
        }
        vehicle.position.set(0,0,0);
        vehicle.rotation.y = Math.PI;
        scene.add(vehicle);
      }

      function createObstacles(count=10) {
        for (let i=0;i<count;i++){
          const w = 8 + Math.random()*36;
          const d = 8 + Math.random()*36;
          const h = 6 + Math.random()*40;
          const mat = new THREE.MeshStandardMaterial({ color: 0x6a6a6a, roughness:0.8 });
          const ob = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
          const z = 60 + Math.random()*800;
          const x = (Math.random()-0.5) * 220;
          ob.position.set(x, h/2, z);
          ob.castShadow = true; ob.receiveShadow = true;
          scene.add(ob);
          obstacles.push(ob);
        }
      }

      function resetScene() {
        // reset vehicle position, remove and recreate obstacles
        vehicle.position.set(0,0,0);
        vehicle.rotation.set(0, Math.PI, 0);
        speed = 0; score = 0; scoreEl.textContent = score; speedEl.textContent = 0;
        for (const ob of obstacles) scene.remove(ob);
        obstacles.length = 0;
        createObstacles(16);
      }

      function onWindowResize() {
        if (!camera || !renderer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Simple collision using bounding boxes
      function checkCollisionWithObstacles(nextPos) {
        const clone = vehicle.clone();
        clone.position.copy(nextPos);
        clone.updateMatrixWorld(true);
        const vbox = new THREE.Box3().setFromObject(clone);
        for (const ob of obstacles) {
          const obb = new THREE.Box3().setFromObject(ob);
          if (vbox.intersectsBox(obb)) return ob;
        }
        return null;
      }

      // Basic particles (small spheres) - low count for stability
      function emitParticles(x,z,color=0x8a7f6e, count=6) {
        for (let i=0;i<count;i++){
          const s = Math.random()*0.08 + 0.04;
          const g = new THREE.Mesh(new THREE.SphereGeometry(s,6,6), new THREE.MeshStandardMaterial({ color: color }));
          g.position.set(x + (Math.random()-0.5)*1.2, 0.3 + Math.random()*0.6, z + (Math.random()-0.5)*1.2);
          g.userData.life = 20 + Math.random()*30;
          scene.add(g);
          particles.push(g);
        }
      }

      function updateParticles() {
        for (let i=particles.length-1; i>=0; i--){
          const p = particles[i];
          p.userData.life -= 1;
          p.position.x += (Math.random()-0.5)*0.02;
          p.position.z += (Math.random()-0.5)*0.02;
          p.position.y += (Math.random()-0.6)*0.02;
          p.material.opacity = Math.max(0, p.userData.life / 60);
          p.material.transparent = true;
          if (p.userData.life <= 0) { scene.remove(p); particles.splice(i,1); }
        }
      }

      // SFX (simple beeps)
      function beep(freq=880, dur=0.06, type='sine', gain=0.08){
        if (!audioCtx) return;
        try {
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type; o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(audioCtx.destination);
          o.start();
          g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
          o.stop(audioCtx.currentTime + dur + 0.02);
        } catch(e){ console.warn('beep fail', e); }
      }

      // crash sfx
      function crashSfx(){ beep(160,0.12,'sawtooth',0.18); }

      // Animation loop
      let last = performance.now();
      let velocity = 0, steering = 0;
      function animate(){
        if (!running) return;
        requestAnimationFrame(animate);
        const now = performance.now();
        const dt = Math.min(40, now - last) / 1000;
        last = now;

        // controls -> acceleration
        const accel = (keys.forward ? 18 : (keys.backward ? -12 : 0));
        const turbo = keys.turbo ? 1.6 : 1.0;
        const drag = 6 + Math.abs(velocity)*0.2;
        velocity += (accel - Math.sign(velocity)*drag) * dt;
        velocity *= (1 - Math.min(dt*0.5, 0.15));

        // steering lerp
        if (keys.left) steering = THREE.MathUtils.lerp(steering, 0.8, 0.08);
        else if (keys.right) steering = THREE.MathUtils.lerp(steering, -0.8, 0.08);
        else steering = THREE.MathUtils.lerp(steering, 0, 0.06);

        // rotate vehicle
        const deltaYaw = steering * 0.9 * dt * (velocity>0 ? 1 : -1);
        vehicle.rotation.y += deltaYaw;

        // compute forward movement
        const forwardVec = new THREE.Vector3(0,0,1).applyQuaternion(vehicle.quaternion).multiplyScalar(velocity * turbo * dt);
        const nextPos = vehicle.position.clone().add(forwardVec);

        // collision check
        const collided = checkCollisionWithObstacles(nextPos);
        if (collided) {
          // collision response
          velocity *= -0.2;
          vehicle.position.add(new THREE.Vector3(0,0.05,0));
          emitParticles(vehicle.position.x, vehicle.position.z, 0xff6b6b, 12);
          crashSfx();
        } else {
          vehicle.position.copy(nextPos);
        }

        // camera follow
        const desired = vehicle.position.clone().add(new THREE.Vector3(0,6,-12).applyQuaternion(vehicle.quaternion));
        camera.position.lerp(desired, 0.12);
        camera.lookAt(vehicle.position.clone().add(new THREE.Vector3(0,1.8,0)));

        // occasional spawning obstacles
        if (obstacles.length < 40 && Math.random() < 0.02) createObstacles(1);

        // update particles
        updateParticles();

        // render
        renderer.render(scene, camera);

        // UI
        speedEl.textContent = Math.round(velocity * 10);
        score += Math.max(0, velocity) * dt * 0.5;
        scoreEl.textContent = Math.floor(score);
      }

      // expose debug start if needed
      window.__urban = { start: ()=>{ startBtn.click(); }, reset: resetScene };

      // initial preview: small canvas background (no heavy init) - already empty body background suffices
      console.log('Prototype prêt. Clique "Démarrer".');
    } // end main

    if (typeof THREE === 'undefined') {
      // try to load from CDN then call main
      loadScript('https://unpkg.com/three@0.152.2/build/three.min.js', function(err){
        if (err) {
          document.getElementById('loading').style.display = 'none';
          alert('Impossible de charger Three.js depuis le CDN. Vérifie ta connexion ou bloqueurs de contenu.');
          console.error(err);
          return;
        }
        main();
      });
    } else {
      main();
    }
  })();
  </script>
</body>
</html>
