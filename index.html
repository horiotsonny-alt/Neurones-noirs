<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Geometry Dash - Prototype Am√©lior√©</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --ui-color:#fff;
      --bg:#222;
      --panel:#2b2b2b;
      --accent:#ffd700;
    }
    html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    #container{position:relative; width:800px; max-width:95vw;}
    canvas{display:block; width:100%; height:auto; background:#444; border:1px solid #666; box-shadow:0 6px 24px rgba(0,0,0,0.6);}
    #ui {
      position:absolute; left:12px; top:12px; color:var(--ui-color); font-size:16px; user-select:none;
      display:flex; gap:12px; align-items:center;
    }
    #rightUI { position:absolute; right:12px; top:12px; color:var(--ui-color); font-size:14px; text-align:right; }
    .btn {
      background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06); color:var(--ui-color); padding:6px 10px; border-radius:6px; cursor:pointer;
      font-size:13px;
    }
    .btn:active{transform:translateY(1px);}
    #overlay {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
    }
    .panel {
      pointer-events:auto;
      background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(255,255,255,0.02));
      padding:18px 22px; border-radius:10px; color:var(--ui-color); text-align:center; border:1px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 30px rgba(0,0,0,0.7);
    }
    .small { font-size:13px; opacity:0.9; }
    .big { font-size:22px; font-weight:700; margin-bottom:8px; }
    #controls-hint { margin-top:8px; color: #ddd; font-size:13px; opacity:0.9; }
    #mobileButtons {
      position:absolute; bottom:16px; left:50%; transform:translateX(-50%); display:flex; gap:8px; pointer-events:auto;
    }
    .mobileBtn { padding:12px 18px; border-radius:10px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06); color:#fff; font-weight:600; }
    @media (max-width:420px){
      #container{width:360px;}
      .big{font-size:18px;}
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas" aria-label="Jeu Geometry Dash prototype"></canvas>

    <div id="ui">
      <div>Score: <strong id="score">0</strong></div>
      <button id="soundToggle" class="btn" title="Activer / d√©sactiver le son">üîä</button>
      <button id="djToggle" class="btn" title="Double jump toggle">Double-jump: ON</button>
    </div>
    <div id="rightUI">
      Best: <strong id="best">0</strong><br>
      Speed: <span id="speedDisplay">1.0x</span>
    </div>

    <div id="overlay">
      <div id="menu" class="panel">
        <div class="big">Geometry Dash - Prototype</div>
        <div class="small">Appuie sur Espace / Tape pour sauter.<br>√âvite les obstacles et fais le meilleur score !</div>
        <div style="height:12px"></div>
        <button id="startBtn" class="btn">D√©marrer</button>
        <div id="controls-hint" class="small">Clavier: Espace / Fl√®che haut = sauter. Mobile: tape l'√©cran.</div>
      </div>
    </div>

    <div id="mobileButtons" style="display:none;">
      <button id="jumpBtn" class="mobileBtn">SAUT</button>
      <button id="restartBtn" class="mobileBtn">RESTART</button>
    </div>
  </div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // D√©finir taille logique + g√©rer devicePixelRatio pour nettet√©
  const CSS_WIDTH = 800;
  const CSS_HEIGHT = 600;
  const DPR = window.devicePixelRatio || 1;
  canvas.width = CSS_WIDTH * DPR;
  canvas.height = CSS_HEIGHT * DPR;
  canvas.style.width = CSS_WIDTH + 'px';
  canvas.style.height = CSS_HEIGHT + 'px';
  ctx.scale(DPR, DPR);

  // Param√®tres
  const groundLevel = 120; // hauteur du sol depuis le bas (px)
  const gravity = 0.9;
  const jumpStrength = -15;
  const playerSize = 32;
  const forwardSpeed = 4; // vitesse √† laquelle les obstacles se rapprochent

  // Player (auto-run)
  const player = {
    x: 100,
    y: CSS_HEIGHT - groundLevel - playerSize,
    width: playerSize,
    height: playerSize,
    vy: 0,
    isJumping: false
  };

  // Obstacles
  const obstacles = [];
  let spawnTimer = 0;
  const spawnInterval = 90; // frames entre spawn
  const obstacleMinHeight = 20;
  const obstacleMaxHeight = 80;

  // Input
  let keyJump = false;
  const scoreEl = document.getElementById('score');
  let score = 0;
  let gameOver = false;

  function resetGame() {
    obstacles.length = 0;
    player.y = CSS_HEIGHT - groundLevel - playerSize;
    player.vy = 0;
    player.isJumping = false;
    spawnTimer = 0;
    score = 0;
    gameOver = false;
    scoreEl.textContent = score;
  }

  // Collision AABB
  function rectsCollide(a, b) {
    return !(a.x + a.width < b.x || a.x > b.x + b.width || a.y + a.height < b.y || a.y > b.y + b.height);
  }

  // G√©n√©rer obstacle
  function spawnObstacle() {
    const h = Math.floor(Math.random() * (obstacleMaxHeight - obstacleMinHeight + 1)) + obstacleMinHeight;
    obstacles.push({
      x: CSS_WIDTH + 10,
      y: CSS_HEIGHT - groundLevel - h,
      width: 28,
      height: h,
      passed: false
    });
  }

  // Events
  document.addEventListener('keydown', (e) => {
    if ((e.code === 'Space' || e.code === 'ArrowUp') && !gameOver) {
      keyJump = true;
      e.preventDefault();
    }
    if (gameOver && (e.code === 'Space' || e.code === 'Enter')) {
      resetGame();
      loop();
    }
  });
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (!gameOver) {
      keyJump = true;
      setTimeout(()=> keyJump = false, 120);
    } else {
      resetGame();
      loop();
    }
  }, { passive: false });

  // Simple mobile buttons
  const jumpBtn = document.getElementById('jumpBtn');
  const restartBtn = document.getElementById('restartBtn');
  jumpBtn.addEventListener('click', ()=> { if(!gameOver){ keyJump = true; setTimeout(()=> keyJump = false, 120); }});
  restartBtn.addEventListener('click', ()=> { if(gameOver){ resetGame(); loop(); }});

  // Game functions
  function update() {
    if (gameOver) return;

    // physics
    player.vy += gravity;
    player.y += player.vy;
    const floorY = CSS_HEIGHT - groundLevel - player.height;
    if (player.y > floorY) {
      player.y = floorY;
      player.vy = 0;
      player.isJumping = false;
    }

    // jump input
    if (keyJump && !player.isJumping) {
      player.vy = jumpStrength;
      player.isJumping = true;
      keyJump = false;
    }

    // obstacles update
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const ob = obstacles[i];
      ob.x -= forwardSpeed;

      if (rectsCollide(player, ob)) {
        gameOver = true;
        playCrash();
        createParticles(player.x + player.width/2, player.y + player.height/2, '#ff5252', 24);
        startShake(10);
        showGameOver();
        return;
      }

      if (!ob.passed && ob.x + ob.width < player.x) {
        ob.passed = true;
        score++;
        scoreEl.textContent = score;
        playScore();
        createParticles(player.x, player.y + 8, '#ffd700', 8);
      }

      if (ob.x < -ob.width) obstacles.splice(i, 1);
    }

    // spawn obstacles
    spawnTimer++;
    if (spawnTimer >= spawnInterval) {
      spawnTimer = 0;
      spawnObstacle();
    }

    updateParticles();
  }

  function draw() {
    // background
    ctx.clearRect(0,0,CSS_WIDTH,CSS_HEIGHT);
    ctx.fillStyle = '#2c2f3a';
    ctx.fillRect(0,0,CSS_WIDTH,CSS_HEIGHT);

    // ground
    ctx.fillStyle = '#161616';
    ctx.fillRect(0, CSS_HEIGHT - groundLevel, CSS_WIDTH, groundLevel);

    // player & obstacles
    drawPlayer();
    for (const ob of obstacles) {
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
    }

    drawParticles();
  }

  function gameLoop() {
    update();
    draw();
    if (!gameOver) requestAnimationFrame(gameLoop);
  }

  // Start the loop
  function loop() {
    gameOver = false;
    resetGame();
    requestAnimationFrame(gameLoop);
  }

  // draw player
  function drawPlayer() {
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(player.x + 6, player.y + player.height - 4, player.width, 8);

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(player.x, player.y, player.width, player.height);
  }

  // Game Over
  function showGameOver() {
    // simple overlay
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,CSS_WIDTH,CSS_HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over - Appuie pour recommencer', CSS_WIDTH/2, CSS_HEIGHT/2);
  }

  // Particles (simple)
  const particles = [];
  function createParticles(x,y,color,count){
    for(let i=0;i<count;i++){
      particles.push({
        x, y,
        vx: (Math.random()-0.5)*6,
        vy: (Math.random()-1.5)*6,
        life: 40 + Math.random()*40,
        size: 2 + Math.random()*3,
        color
      });
    }
  }
  function updateParticles(){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vy += 0.2;
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 1;
      if(p.life <= 0) particles.splice(i,1);
    }
  }
  function drawParticles(){
    for(const p of particles){
      ctx.globalAlpha = Math.max(0, p.life/70);
      ctx.fillStyle = p.color;
      ctx.fillRect(Math.round(p.x), Math.round(p.y), p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }

  // Screen shake
  let shake = {intensity:0, decay:0.9, dx:0, dy:0};
  function startShake(intensity){
    shake.intensity = Math.max(shake.intensity, intensity);
  }
  function applyShake(){
    if(shake.intensity > 0.1){
      shake.dx = (Math.random()*2-1) * shake.intensity;
      shake.dy = (Math.random()*2-1) * shake.intensity * 0.6;
      ctx.save();
      ctx.translate(shake.dx, shake.dy);
      shake.intensity *= shake.decay;
    }
  }
  function restoreShake(){
    if(shake.dx || shake.dy) ctx.restore();
  }

  // Simple audio fx (WebAudio)
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function playBeep(freq, dur, type='sine', gain=0.12){
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    o.stop(audioCtx.currentTime + dur + 0.02);
  }
  function playJump(){ playBeep(880, 0.08, 'sine', 0.12); }
  function playScore(){ playBeep(1200, 0.045, 'square', 0.08); }
  function playCrash(){ playBeep(160, 0.18, 'sawtooth', 0.2); }

  // small start button wiring (menu)
  const startBtn = document.getElementById('startBtn');
  startBtn.addEventListener('click', ()=>{
    // unlock audio on interaction
    ensureAudio();
    loop();
  });

  // basic keyboard jump handling (global)
  document.addEventListener('keydown', (e)=>{
    if((e.code === 'Space' || e.code === 'ArrowUp') && !gameOver){
      if(!player.isJumping){
        player.vy = jumpStrength;
        player.isJumping = true;
        playJump();
      }
    }
  });

  // Start paused so player clicks start
  draw();
</script>
</body>
</html>
