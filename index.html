<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Geometry Dash - Prototype AmÃ©liorÃ©</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --ui-color:#fff;
      --bg:#222;
      --panel:#2b2b2b;
      --accent:#ffd700;
    }
    html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    #container{position:relative; width:800px; max-width:95vw;}
    canvas{display:block; width:100%; height:auto; background:#444; border:1px solid #666; box-shadow:0 6px 24px rgba(0,0,0,0.6);}
    #ui {
      position:absolute; left:12px; top:12px; color:var(--ui-color); font-size:16px; user-select:none;
      display:flex; gap:12px; align-items:center;
    }
    #rightUI { position:absolute; right:12px; top:12px; color:var(--ui-color); font-size:14px; text-align:right; }
    .btn {
      background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06); color:var(--ui-color); padding:6px 10px; border-radius:6px; cursor:pointer;
      font-size:13px;
    }
    .btn:active{transform:translateY(1px);}
    #overlay {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
    }
    .panel {
      pointer-events:auto;
      background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(255,255,255,0.02));
      padding:18px 22px; border-radius:10px; color:var(--ui-color); text-align:center; border:1px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 30px rgba(0,0,0,0.7);
    }
    .small { font-size:13px; opacity:0.9; }
    .big { font-size:22px; font-weight:700; margin-bottom:8px; }
    #controls-hint { margin-top:8px; color: #ddd; font-size:13px; opacity:0.9; }
    #mobileButtons {
      position:absolute; bottom:16px; left:50%; transform:translateX(-50%); display:flex; gap:8px; pointer-events:auto;
    }
    .mobileBtn { padding:12px 18px; border-radius:10px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06); color:#fff; font-weight:600; }
    @media (max-width:420px){
      #container{width:360px;}
      .big{font-size:18px;}
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas" aria-label="Jeu Geometry Dash prototype"></canvas>

    <div id="ui">
      <div>Score: <strong id="score">0</strong></div>
      <button id="soundToggle" class="btn" title="Activer / dÃ©sactiver le son">ðŸ”Š</button>
      <button id="djToggle" class="btn" title="Double jump toggle">Double-jump: ON</button>
    </div>
    <div id="rightUI">
      Best: <strong id="best">0</strong><br>
      Speed: <span id="speedDisplay">1.0x</span>
    </div>

    <div id="overlay">
      <div id="menu" class="panel">
        <div class="big">Geometry Dash - Prototype</div>
        <div class="small">Appuie sur Espace / Tape pour sauter.<br>Ã‰vite les obstacles et fais le meilleur score !</div>
        <div style="height:12px"></div>
        <button id="startBtn" class="btn">DÃ©marrer</button>
        <div id="controls-hint" class="small">Clavier: Espace / FlÃ¨che haut = sauter. Mobile: tape l'Ã©cran.</div>
      </div>
    </div>

    <div id="mobileButtons" style="display:none;">
      <button id="jumpBtn" class="mobileBtn">SAUT</button>
      <button id="restartBtn" class="mobileBtn">RESTART</button>
    </div>
  </div>

<script>
/*
  Geometry Dash - Prototype AmÃ©liorÃ©
  - Parallax background
  - Obstacles variÃ©s (block, spike, moving)
  - Difficulty scaling
  - Score + best in localStorage
  - Menu, GameOver, restart
  - Double-jump option
  - Sounds via WebAudio (no external files)
  - Retina/dpr scaling
  - Touch controls and mobile buttons
*/

/* ========== Setup canvas & scaling ========== */
const CSS_W = 800;
const CSS_H = 600;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvasForDPR() {
  const DPR = window.devicePixelRatio || 1;
  // Keep fixed logical size for gameplay, scale physical pixels
  canvas.width = CSS_W * DPR;
  canvas.height = CSS_H * DPR;
  canvas.style.width = CSS_W + 'px';
  canvas.style.height = CSS_H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resizeCanvasForDPR();
window.addEventListener('resize', () => {
  // keep style size constant; we don't change CSS_W/CSS_H here
  // but reapply DPR scaling in case devicePixelRatio changed
  resizeCanvasForDPR();
});

/* ========== Game variables ========== */
let state = 'menu'; // 'menu', 'playing', 'gameover'
const groundHeight = 120;
const gravity = 0.95;
const jumpStrength = -16;
const playerSize = 36;
let baseSpeed = 4; // world speed (obstacles move left)
let speedMultiplier = 1;
let spawnInterval = 95; // frames (will decrease)
let spawnTimer = 0;
let obstacles = [];
let frameCount = 0;
let score = 0;
const bestKey = 'gd_prototype_best_v1';
let best = Number(localStorage.getItem(bestKey) || 0);
document.getElementById('best').textContent = best;

const scoreEl = document.getElementById('score');
const speedDisplay = document.getElementById('speedDisplay');

/* Player */
const player = {
  x: 120,
  y: CSS_H - groundHeight - playerSize,
  width: playerSize,
  height: playerSize,
  vy: 0,
  isJumping: false,
  doubleJumpAvailable: true,
  hitboxInset: 6 // shrink hitbox a bit for fairer collisions
};

/* Parallax layers */
const parallax = [
  { speed: 0.2, color: '#1d1f2a', items: [] },
  { speed: 0.4, color: '#2a2d3b', items: [] },
  { speed: 0.75, color: '#333744', items: [] }
];
// generate simple shapes for layers (rectangles/hills)
function initParallax() {
  parallax.forEach((layer, li) => {
    layer.items = [];
    const count = 8 + li * 4;
    for (let i = 0; i < count; i++) {
      layer.items.push({
        x: i * (CSS_W / (count - 1)) + Math.random()*200,
        y: CSS_H - groundHeight - (30 + li*20) - Math.random() * 40,
        w: 80 + Math.random() * 160,
        h: 20 + li*20 + Math.random() * 40,
      });
    }
  });
}
initParallax();

/* UI elements */
const overlay = document.getElementById('overlay');
const menu = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
const soundToggle = document.getElementById('soundToggle');
const djToggle = document.getElementById('djToggle');
const mobileBtns = document.getElementById('mobileButtons');
const jumpBtn = document.getElementById('jumpBtn');
const restartBtn = document.getElementById('restartBtn');

let soundOn = true;
let allowDoubleJump = true;
djToggle.textContent = 'Double-jump: ON';

/* ========== Audio (WebAudio simple effects) ========== */
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}
function playBeep(freq=880, duration=0.06, type='sine', gain=0.12) {
  if (!soundOn) return;
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
  o.stop(audioCtx.currentTime + duration + 0.02);
}
function playJump() { playBeep(880, 0.08, 'sine', 0.12); }
function playScore() { playBeep(1200, 0.045, 'square', 0.08); }
function playCrash() { playBeep(160, 0.18, 'sawtooth', 0.2); }

/* ========== Obstacles generation ========== */
function randomBetween(a,b){ return a + Math.random()*(b-a); }

function spawnObstacle() {
  // choose type by weighted chance
  const r = Math.random();
  if (r < 0.55) {
    // block
    const h = 28 + Math.floor(Math.random()*80);
    obstacles.push({
      type: 'block',
      x: CSS_W + 20,
      y: CSS_H - groundHeight - h,
      width: 28 + Math.floor(Math.random()*30),
      height: h,
      speedMod: 0
    });
  } else if (r < 0.85) {
    // spike (short, triangular but represented by rect for collision)
    obstacles.push({
      type: 'spike',
      x: CSS_W + 20,
      y: CSS_H - groundHeight - 22,
      width: 36,
      height: 22,
      speedMod: 0
    });
  } else {
    // moving vertical obstacle
    const h = 40 + Math.floor(Math.random()*60);
    const baseY = CSS_H - groundHeight - h;
    obstacles.push({
      type: 'moving',
      x: CSS_W + 20,
      y: baseY - Math.random()*120,
      baseY: baseY,
      width: 30,
      height: h,
      phase: Math.random()*Math.PI*2,
      amp: 40 + Math.random()*60
    });
  }
}

/* ========== Input handling ========== */
let keys = {};
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    keys.jump = true;
    e.preventDefault();
    if (state === 'menu') startGame();
    if (state === 'gameover') restartGame();
  }
  if (e.code === 'KeyM') {
    toggleSound();
  }
});
window.addEventListener('keyup', (e)=> {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    keys.jump = false;
  }
});

// Touch: tap to jump / restart
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (state === 'menu') startGame();
  else if (state === 'gameover') restartGame();
  else if (state === 'playing') {
    keys.jump = true;
    // release after small delay to simulate keyup
    setTimeout(()=> keys.jump = false, 120);
  }
}, {passive:false});

/* Mobile buttons display when small screen */
function updateMobileButtonsVisibility(){
  if (window.innerWidth <= 480) {
    mobileBtns.style.display = 'flex';
  } else {
    mobileBtns.style.display = 'none';
  }
}
updateMobileButtonsVisibility();
window.addEventListener('resize', updateMobileButtonsVisibility);
jumpBtn.addEventListener('click', ()=> { keys.jump = true; setTimeout(()=> keys.jump=false, 120); });
restartBtn.addEventListener('click', ()=> {
  if (state === 'gameover') restartGame();
});

/* UI button handlers */
startBtn.addEventListener('click', startGame);
soundToggle.addEventListener('click', toggleSound);
djToggle.addEventListener('click', () => {
  allowDoubleJump = !allowDoubleJump;
  djToggle.textContent = 'Double-jump: ' + (allowDoubleJump ? 'ON' : 'OFF');
});

/* ========== Game logic ========== */
function resetState() {
  player.x = 120;
  player.y = CSS_H - groundHeight - playerSize;
  player.vy = 0;
  player.isJumping = false;
  player.doubleJumpAvailable = allowDoubleJump;
  obstacles = [];
  spawnTimer = 0;
  frameCount = 0;
  score = 0;
  baseSpeed = 4;
  speedMultiplier = 1;
  spawnInterval = 95;
  scoreEl.textContent = score;
  speedDisplay.textContent = speedMultiplier.toFixed(2) + 'x';
  initParallax();
}

function startGame() {
  // unlock audio on first interaction
  if (soundOn) ensureAudio();
  resetState();
  state = 'playing';
  overlay.style.pointerEvents = 'none';
  overlay.style.opacity = '0';
  menu.style.display = 'none';
  requestAnimationFrame(loop);
}

function restartGame() {
  resetState();
  state = 'playing';
  overlay.style.pointerEvents = 'none';
  overlay.style.opacity = '0';
  menu.style.display = 'none';
  requestAnimationFrame(loop);
}

function endGame() {
  state = 'gameover';
  playCrash();
  // save best
  if (score > best) {
    best = score;
    localStorage.setItem(bestKey, best);
    document.getElementById('best').textContent = best;
  }
  showGameOverPanel();
}

/* ========== Collision check with shrunk hitbox for fairness ========== */
function rectsCollide(a, b) {
  const ax = a.x + (a.hitboxInset||0);
  const ay = a.y + (a.hitboxInset||0);
  const aw = a.width - 2*(a.hitboxInset||0);
  const ah = a.height - 2*(a.hitboxInset||0);
  return !(ax + aw < b.x || ax > b.x + b.width || ay + ah < b.y || ay > b.y + b.height);
}

/* ========== Draw helpers ========== */
function drawBackground() {
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,CSS_H);
  g.addColorStop(0, '#2c2f3a');
  g.addColorStop(1, '#1b1d22');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,CSS_W,CSS_H);

  // parallax layers (hills/rects)
  parallax.forEach((layer, li) => {
    ctx.fillStyle = layer.color;
    for (const it of layer.items) {
      let x = it.x - (frameCount * layer.speed * speedMultiplier % (CSS_W+200));
      // wrap
      const w = it.w;
      const nx = ((x % (CSS_W + 300)) + (CSS_W+300)) % (CSS_W+300) - 150;
      ctx.beginPath();
      const hillY = it.y;
      ctx.ellipse(nx + w/2, hillY, w, it.h, 0, 0, Math.PI*2);
      ctx.fill();
    }
  });

  // ground
  ctx.fillStyle = '#161616';
  ctx.fillRect(0, CSS_H - groundHeight, CSS_W, groundHeight);

  // ground stripe / grid for motion
  ctx.fillStyle = '#242424';
  for (let gx = -Math.floor(frameCount * 1.6 * speedMultiplier) % 40; gx < CSS_W; gx += 40) {
    ctx.fillRect(gx, CSS_H - 22, 20, 6);
  }
}

/* Player draw (simple square with small shadow) */
function drawPlayer() {
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(player.x + 6, player.y + player.height - 4, player.width, 8);

  ctx.fillStyle = '#ffffff';
  ctx.fillRect(Math.round(player.x), Math.round(player.y), player.width, player.height);

  // small eyes to feel alive
  ctx.fillStyle = '#000';
  ctx.fillRect(player.x + 8, player.y + 10, 6, 6);
  ctx.fillRect(player.x + 22, player.y + 10, 6, 6);
}

/* Obstacles draw */
function drawObstacle(ob) {
  if (ob.type === 'block') {
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(Math.round(ob.x), Math.round(ob.y), ob.width, ob.height);
    // highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.strokeRect(Math.round(ob.x)+0.5, Math.round(ob.y)+0.5, ob.width-1, ob.height-1);
  } else if (ob.type === 'spike') {
    // draw triangular spikes
    ctx.fillStyle = '#ff5252';
    const left = ob.x, top = ob.y, w = ob.width, h = ob.height;
    const spikeCount = 3;
    const sw = w / spikeCount;
    for (let i=0;i<spikeCount;i++){
      const sx = left + i*sw;
      ctx.beginPath();
      ctx.moveTo(sx, top + h);
      ctx.lineTo(sx + sw/2, top);
      ctx.lineTo(sx + sw, top + h);
      ctx.closePath();
      ctx.fill();
    }
  } else if (ob.type === 'moving') {
    ctx.fillStyle = '#6ee7b7';
    ctx.fillRect(Math.round(ob.x), Math.round(ob.y), ob.width, ob.height);
  }
}

/* ========== Game update ========== */
function updateGame() {
  frameCount++;

  // difficulty progression
  if (frameCount % 240 === 0) {
    // every 240 frames (~4s at 60fps) increase speed slightly
    speedMultiplier += 0.03;
    if (spawnInterval > 42) spawnInterval -= 1;
  }
  speedDisplay.textContent = (speedMultiplier).toFixed(2) + 'x';

  // handle input - jump
  if (keys.jump) {
    if (!player.isJumping) {
      player.vy = jumpStrength;
      player.isJumping = true;
      player.doubleJumpAvailable = allowDoubleJump; // allow one double when starting jump
      playJump();
    } else if (player.isJumping && player.doubleJumpAvailable && allowDoubleJump) {
      // double jump
      player.vy = jumpStrength * 0.85;
      player.doubleJumpAvailable = false;
      playJump();
    }
    keys.jump = false; // simulate short press
  }

  // physics
  player.vy += gravity;
  player.y += player.vy;
  const floorY = CSS_H - groundHeight - player.height;
  if (player.y > floorY) {
    player.y = floorY;
    player.vy = 0;
    player.isJumping = false;
    player.doubleJumpAvailable = allowDoubleJump; // reset double jump when grounded
  }

  // update obstacles positions and behaviors
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const ob = obstacles[i];
    // type-specific movement
    if (ob.type === 'moving') {
      ob.phase += 0.06;
      ob.y = ob.baseY + Math.sin(ob.phase) * ob.amp;
    }
    ob.x -= baseSpeed * speedMultiplier * (1 + (ob.speedMod || 0));

    // collision
    if (rectsCollide(player, ob)) {
      endGame();
      return;
    }

    // scoring
    if (!ob.passed && ob.x + ob.width < player.x) {
      ob.passed = true;
      score += 1;
      scoreEl.textContent = score;
      playScore();
    }

    // remove off-screen
    if (ob.x + ob.width < -60) {
      obstacles.splice(i,1);
    }
  }

  // spawn obstacles
  spawnTimer++;
  if (spawnTimer >= spawnInterval) {
    spawnTimer = 0;
    spawnObstacle();
  }
}

/* ========== Draw loop ========== */
function draw() {
  // clear & draw bg
  drawBackground();

  // draw obstacles
  for (const ob of obstacles) drawObstacle(ob);

  // draw player
  drawPlayer();
}

/* ========== Game loop ========== */
let rafId = null;
function loop() {
  if (state !== 'playing') return;
  updateGame();
  draw();
  rafId = requestAnimationFrame(loop);
}

/* ========== Menu / GameOver panels ========== */
function showGameOverPanel() {
  overlay.style.pointerEvents = 'auto';
  overlay.style.opacity = '1';
  menu.style.display = 'block';
  menu.innerHTML = `
    <div class="big">Game Over</div>
    <div class="small">Score: <strong>${score}</strong></div>
    <div style="height:8px"></div>
    <div class="small">Best: <strong>${best}</strong></div>
    <div style="height:12px"></div>
    <button id="restartNow" class="btn">Recommencer</button>
    <div style="height:10px"></div>
    <div class="small">Appuie sur Espace ou tape pour recommencer</div>
  `;
  document.getElementById('restartNow').addEventListener('click', restartGame);
}

/* ========== Sound toggle ========== */
function toggleSound() {
  soundOn = !soundOn;
  soundToggle.textContent = soundOn ? 'ðŸ”Š' : 'ðŸ”ˆ';
  if (soundOn) {
    // resume audio context if existed and was suspended
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  }
}

/* ========== Initial state & bindings ========== */
document.getElementById('best').textContent = best;
startBtn.focus();
soundToggle.textContent = soundOn ? 'ðŸ”Š' : 'ðŸ”ˆ';

/* Visual: show menu overlay initially */
overlay.style.pointerEvents = 'auto';
overlay.style.opacity = '1';
menu.style.display = 'block';

/* ========== Helpful: pause on visibility change ========== */
document.addEventListener('visibilitychange', () => {
  if (document.hidden && state === 'playing') {
    // pause
    cancelAnimationFrame(rafId);
    rafId = null;
  } else if (!document.hidden && state === 'playing' && !rafId) {
    rafId = requestAnimationFrame(loop);
  }
});

/* Optional: let user click anywhere to start from menu */
canvas.addEventListener('click', ()=> {
  if (state === 'menu') startGame();
  else if (state === 'gameover') restartGame();
});

/* Ready */
</script>
</body>
</html>
