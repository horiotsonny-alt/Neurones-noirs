<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Neurones Noirs – Run</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, Helvetica, sans-serif;
      touch-action: none;
      user-select: none;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 15px;
      color: white;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 6px black, 0 0 12px black;
      pointer-events: none;
      z-index: 10;
    }
    #gameOver {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.85);
      color: #ff4444;
      font-size: 80px;
      font-weight: bold;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-shadow: 0 0 15px black;
      z-index: 20;
      display: none;
    }
    #gameOver button {
      margin-top: 40px;
      padding: 16px 60px;
      font-size: 36px;
      background: #22ff44;
      color: black;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 0 20px #22ff44;
    }
    #jumpBtn {
      position: fixed;
      bottom: 50px;
      right: 50px;
      width: 110px;
      height: 110px;
      background: rgba(255,140,0,0.75);
      border: none;
      border-radius: 999px;
      color: white;
      font-size: 60px;
      font-weight: bold;
      z-index: 15;
      box-shadow: 0 8px 25px rgba(0,0,0,0.6);
      touch-action: manipulation;
    }
    #jumpBtn:active {
      transform: scale(0.92);
      background: rgba(255,180,60,0.95);
    }
  </style>
</head>
<body>

<div id="ui">
  Score: <span id="score">0</span>  –  Coins: <span id="coins">0</span>
</div>

<div id="gameOver">
  GAME OVER
  <button id="restart">Rejouer</button>
</div>

<button id="jumpBtn">↑</button>

<script>
// ────────────────────────────────────────────────
// Jeu style Subway Surfers – version simplifiée & corrigée
// ────────────────────────────────────────────────

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x220033);
scene.fog = new THREE.FogExp2(0x110022, 0.002);

const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 2000);
camera.position.set(0, 5, 12);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lumières
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const sun = new THREE.DirectionalLight(0xffeecc, 1.3);
sun.position.set(20, 40, 15);
sun.castShadow = true;
scene.add(sun);

// Variables globales
let score = 0;
let coins = parseInt(localStorage.getItem("nn_coins") || "0");
let speed = 0.22;
let gameRunning = true;

document.getElementById("coins").textContent = coins;

// ──── Joueur ────────────────────────────────────────
const playerGroup = new THREE.Group();
scene.add(playerGroup);

const bodyGeo = new THREE.BoxGeometry(1.3, 1.8, 1.4);
const bodyMat = new THREE.MeshStandardMaterial({color: 0xffdd00});
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.position.y = 0.9;
body.castShadow = true;
playerGroup.add(body);

const headGeo = new THREE.SphereGeometry(0.65, 16, 16);
const head = new THREE.Mesh(headGeo, bodyMat);
head.position.y = 2.0;
playerGroup.add(head);

playerGroup.position.set(0, 0, 0);

let currentLane = 0;          // -1 | 0 | 1
let targetLane = 0;
let velocityY = 0;
let isJumping = false;

// ──── Voies ─────────────────────────────────────────
const LANE_POS = [-3.5, 0, 3.5];
const trackPieces = [];
const trackLength = 40;

for (let i = 0; i < trackLength; i++) {
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(18, 12),
    new THREE.MeshStandardMaterial({color: 0x222233, roughness: 0.9})
  );
  floor.rotation.x = -Math.PI / 2;
  floor.position.z = -i * 12;
  floor.receiveShadow = true;
  scene.add(floor);
  trackPieces.push(floor);

  // Rails
  [-1, 1].forEach(side => {
    const rail = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 0.4, 12.5),
      new THREE.MeshStandardMaterial({color: 0x555577, metalness: 0.7})
    );
    rail.position.set(side * 5.8, 0.2, -i * 12);
    scene.add(rail);
    trackPieces.push(rail);
  });
}

// ──── Obstacles (trains / barrières) ─────────────────
const obstacles = [];

function spawnObstacle() {
  const lane = Math.floor(Math.random() * 3) - 1;
  const isTall = Math.random() < 0.4; // ~40% de hauts (à esquiver latéralement)

  const w = isTall ? 4.5 : 3.8;
  const h = isTall ? 5.5 : 2.8;
  const d = 5 + Math.random() * 3;

  const obs = new THREE.Mesh(
    new THREE.BoxGeometry(w, h, d),
    new THREE.MeshStandardMaterial({color: 0xdd0000, emissive: 0x880000})
  );
  obs.position.set(LANE_POS[lane + 1], h/2, -80 - Math.random() * 60);
  obs.castShadow = true;
  scene.add(obs);

  obstacles.push({mesh: obs, tall: isTall});
}

// ──── Pièces ────────────────────────────────────────
const collectibles = [];

function spawnCoin() {
  const lane = Math.floor(Math.random() * 3) - 1;
  const coin = new THREE.Mesh(
    new THREE.SphereGeometry(0.9, 16, 16),
    new THREE.MeshStandardMaterial({
      color: 0xffff00,
      emissive: 0xffff44,
      emissiveIntensity: 1.2
    })
  );
  coin.position.set(LANE_POS[lane + 1], 2.5 + Math.random()*1.5, -90 - Math.random()*80);
  scene.add(coin);
  collectibles.push(coin);
}

// ──── Contrôles ─────────────────────────────────────
const jumpBtn = document.getElementById("jumpBtn");
jumpBtn.addEventListener("pointerdown", e => {
  e.preventDefault();
  if (!gameRunning) return;
  if (!isJumping) {
    velocityY = 0.38;
    isJumping = true;
  }
});

document.addEventListener("keydown", e => {
  if (!gameRunning) return;
  if (e.code === "Space" || e.code === "ArrowUp") {
    e.preventDefault();
    if (!isJumping) {
      velocityY = 0.38;
      isJumping = true;
    }
  }
  if (e.code === "ArrowLeft" && currentLane > -1) targetLane--;
  if (e.code === "ArrowRight" && currentLane < 1)  targetLane++;
});

// Swipe mobile
let touchStartX = 0;
document.addEventListener("touchstart", e => {
  if (e.touches.length === 1) touchStartX = e.touches[0].clientX;
}, {passive: false});

document.addEventListener("touchend", e => {
  if (e.changedTouches.length !== 1) return;
  const dx = e.changedTouches[0].clientX - touchStartX;
  if (Math.abs(dx) > 60) {
    if (dx > 0 && currentLane < 1) targetLane++;
    if (dx < 0 && currentLane > -1) targetLane--;
  }
}, {passive: false});

// ──── Boucle principale ──────────────────────────────
function animate() {
  if (!gameRunning) return;

  requestAnimationFrame(animate);

  const dt = 1 / 60; // approximation stable

  // Déplacement latéral fluide
  currentLane += (targetLane - currentLane) * 0.28;
  playerGroup.position.x = THREE.MathUtils.lerp(playerGroup.position.x, LANE_POS[Math.round(currentLane)], 0.22);

  // Saut / gravité
  velocityY -= 0.022;
  playerGroup.position.y += velocityY;

  if (playerGroup.position.y <= 0) {
    playerGroup.position.y = 0;
    velocityY = 0;
    isJumping = false;
  }

  // Défilement du monde
  const move = speed * 60 * dt;
  trackPieces.forEach(p => {
    p.position.z += move;
    if (p.position.z > 50) p.position.z -= trackLength * 12;
  });

  obstacles.forEach((o, i) => {
    o.mesh.position.z += move;
    if (o.mesh.position.z > 20) {
      scene.remove(o.mesh);
      obstacles.splice(i, 1);
    }
  });

  collectibles.forEach((c, i) => {
    c.position.z += move;
    c.rotation.y += 0.08;
    if (c.position.z > 20) {
      scene.remove(c);
      collectibles.splice(i, 1);
    }
  });

  // Collision
  let crashed = false;
  for (let o of obstacles) {
    const dx = Math.abs(playerGroup.position.x - o.mesh.position.x);
    const dy = Math.abs(playerGroup.position.y - o.mesh.position.y);
    const dz = Math.abs(playerGroup.position.z - o.mesh.position.z);

    if (dx < 2.6 && dz < 3.2 && dy < (o.tall ? 4 : 2.5)) {
      crashed = true;
      break;
    }
  }

  if (crashed) {
    gameRunning = false;
    document.getElementById("gameOver").style.display = "flex";
  }

  // Ramassage pièces
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const c = collectibles[i];
    const dx = Math.abs(playerGroup.position.x - c.position.x);
    const dy = Math.abs(playerGroup.position.y - c.position.y);
    const dz = Math.abs(playerGroup.position.z - c.position.z);

    if (dx < 1.8 && dy < 2.5 && dz < 1.8) {
      coins++;
      localStorage.setItem("nn_coins", coins);
      document.getElementById("coins").textContent = coins;
      scene.remove(c);
      collectibles.splice(i, 1);
    }
  }

  // Score & vitesse
  score += speed * 18;
  document.getElementById("score").textContent = Math.floor(score);
  speed += 0.00008;

  // Caméra suit le joueur (style Subway Surfers)
  camera.position.x = playerGroup.position.x * 0.3;
  camera.position.y = playerGroup.position.y + 5;
  camera.position.z = playerGroup.position.z + 12;
  camera.lookAt(playerGroup.position.x, playerGroup.position.y + 3, playerGroup.position.z - 30);

  renderer.render(scene, camera);
}

// Génération périodique
setInterval(() => {
  if (gameRunning && Math.random() < 0.75) spawnObstacle();
}, 1400);

setInterval(() => {
  if (gameRunning) spawnCoin();
}, 2200);

// Restart
document.getElementById("restart").onclick = () => {
  gameRunning = true;
  score = 0;
  speed = 0.22;
  currentLane = targetLane = 0;
  velocityY = 0;
  isJumping = false;
  playerGroup.position.set(0, 0, 0);

  obstacles.forEach(o => scene.remove(o.mesh));
  collectibles.forEach(c => scene.remove(c));
  obstacles.length = 0;
  collectibles.length = 0;

  document.getElementById("gameOver").style.display = "none";
  document.getElementById("score").textContent = "0";

  animate();
};

// Resize
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Démarrage
animate();
</script>
</body>
</html>
